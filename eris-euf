#!/usr/bin/env python3

from flask import Flask, json, request, jsonify, redirect, url_for
from werkzeug.serving import make_server
import sys
from os import listdir
from os.path import join, dirname, abspath, isdir
from threading import Thread, Lock
from argparse import ArgumentParser
import time
from collections import namedtuple


def add_third_party_dir(f):
    base_path = dirname(abspath(f))
    tp_dir = join(base_path, "third_party")

    for e in listdir(tp_dir):
        if isdir(join(tp_dir, e)):
            sys.path.append(join(tp_dir, e))

add_third_party_dir(__file__)
from eris import ErisCtrl, ErisCtrlError
from pareto import paretoOptimize

try:
    from eris_model import Eris
    from hardware_model import Hardware
except ImportError:
    print("Model files are missing. Abort", file=sys.stderr)
#    sys.exit(1)



# All the REST API stuff
app = Flask(__name__)

@app.route("/", methods=["GET"])
def index():
    return redirect(url_for("service_status"))

@app.route("/configurations", methods=["GET"])
def configurations():
    global euf_mgr

    return "TBD"

@app.route("/servicestatus", methods=["GET"])
def service_status():
    global euf_mgr

    euf_on = euf_mgr.euf()
    return jsonify({"adaptOn" : False, "eclOn" : euf_on})

@app.route("/services/<stype>/<status>", methods=["POST"])
def services(stype, status):
    global euf_mgr

    if stype == "adapton":
        pass
    elif stype == "eclon":
        if int(status) == 1:
            euf_mgr.euf_on()
        else:
            euf_mgr.euf_off()
    else:
        return '',400

    return '',200

@app.route("/benchmark/sessions")
def sessions():
    return jsonify({"managedBenchmarks" : [ { "name" : "sigmod-demo" } ]})

@app.route("/benchmark/setbenchmark/<session>/<bench>", methods=["POST"])
def set_benchmark(session, bench):
    global euf_mgr

    success = euf_mgr.set_benchmark(bench)

    return '', 200 if success else 400

@app.route("/benchmark/setprofile/<session>/<profile>", methods=["POST"])
def set_profile(session, profile):
    success = euf_mgr.set_profile(profile)

    return '', 200 if success else 400

class FlaskThread(Thread):
    def __init__(self, app, euf):
        super().__init__()

        # Create the flask server using werkzeug
        self._server = make_server("localhost", 5000, app)
        self._ctx = app.app_context()
        self._ctx.push()

        # Save the EUF thread in the global context so that we can access it from
        # inside the requests
        global euf_mgr
        euf_mgr = euf

    def run(self):
        self._server.serve_forever()

    def shutdown(self):
        self._ctx.pop()
        self._server.shutdown()


class EUFThread(Thread):
    Config = namedtuple("Config", ["freq", "cores", "ht", "cpus", "ipc", "p_pkg", "tps"])

    def __init__(self, ectrl):
        super().__init__()

        self._ectrl = ectrl
        self._lock = Lock()
        self.eufon = True

        # Register the counters
        self.counters = {}
        for ctr in ectrl.counters():
            if ctr.dist_name == "Tasks.Started":
                self.counters["started"] = ctr.monitor()
            elif ctr.dist_name == "Tasks.Finished":
                self.counters["finished"] = ctr.monitor()
            elif ctr.dist_name == "Tasks.Latency Average":
                self.counters["latency"] = ctr.monitor()

        # Get all the workers
        self.workers = ectrl.workers()

        # Get the demo session
        self.session = ectrl.session("demo-sigmod")

        print("Available benchmarks:")
        for n, b in self.session.benchmarks.items():
            print("{}: {}".format(n, b.name))

        print("Available profiles:")
        for n, p in self.session.profiles.items():
            print("{}: {}".format(n, p.name))

        # Internal management data
        self._changed = True
        self._current_bench = None

        self._configurations = None
        self._active_configuration = None

    # Other support functions
    def get_configurations(self):
        with self._lock:
            return self._configurations

    def get_active_configuration(self):
        with self._lock:
            return self._active_configuration

    def set_benchmark(self, bench_id):
        with self._lock:
            success = self.session._activate_benchmark(bench_id)
            self.session._update()
            self._changed = True

            return success

    def set_profile(self, profile_id):
        with self._lock:
            success = self.session._activate_profile(profile_id)
            self.session._update()
            self._changed = True

            return success

    def euf_on(self):
        with self._lock:
            self.eufon = True
            self._changed = True

    def euf_off(self):
        with self._lock:
            self.eufon = False
            self._changed = True

    def euf(self):
        with self._lock:
            return self.eufon

    # EUF related functions
    def _current_bench(self, refresh=True):
        if refresh:
            self.session._update()

        for b in self.session.benchmarks:
            if b.active(False):
                return b.name

        return None

    def _current_profile(self, refresh=True):
        if refresh:
            self.session._update()

        for p in self.session.profiles:
            if p.active(False):
                return p.name

        return None

    def _update_configurations(self):
        print("Updating configurations")

        self._configurations = []
        if not self.eufon:
            freq = max(Hardware.config["freq"])
            cores = max(Hardware.config["cores"])

            self._configurations.append(EUFThread.Config(freq=freq,
                                                         cores=cores,
                                                         ht=True,
                                                         cpus=2*cores,
                                                         ipc=0, p_pkg=0, tps=0))
            return
        elif self._current_bench(False) is None:
            freq = min(Hardware.config["freq"])
            cores = min(Hardware.config["cores"])

            self._configurations.append(EUFThread.Config(freq=freq,
                                                         cores=cores,
                                                         ht=False,
                                                         cpus=cores,
                                                         ipc=0, p_pkg=0, tps=0))
            return
        else:
            b = self._current_bench(False)
            print("Building configuration for {}".format(b.name))

            # Generate all possible configurations based on the models
            all_configurations = []
            for freq in Hardware.config['freq']:
                for cores in Hardware.config['cores']:
                    for ht in Hardware.config['ht']:
                        cpus = (ht+1)*cores
                        params = Eris(cpus).benchmarks(b.name)
                        ipc = Hardware.IPC(ht=ht,
                                memory_heaviness=params["memory_heaviness"](),avx_heaviness=params["avx_heaviness"](),
                                compute_heaviness=params["compute_heaviness"](),cache_heaviness=params["cache_heaviness"](),cpus=cpus,freq=freq)
                        p_pkg = Hardware.P_PKG(memory_heaviness=params["memory_heaviness"](),
                                IPC=ipc,freq=freq,avx_heaviness=params["avx_heaviness"](),compute_heaviness=params["compute_heaviness"](),cpus=cpus)
                        tps = (freq*1000)/(params["ipt"]()/ipc)

                        all_configurations.append(EUFThread.Config(freq=freq, cores=cores, ht=True if ht == 1 else False,
                                                                   cpus = cpus, ipc=ipc, p_pkg=p_pkg, tps=tps))

            # Reduce the number of configurations to the pareto optimal ones
            self._configurations = paretoOptimize(all_configurations, ["<p_pkg", ">tps"])

    def _find_best_configuration(self, target_tps):
        # TODO: Actually find the best configuration for the current situation
        return self._configurations[0]

    def _apply_configuration(self, config):
        if self._active_configuration == config:
            return

        workers = []
        for i in range(config.cores):
            workers.append(i)
        if config.ht:
            for i in range(config.cores):
                workers.append(i + 2) #max(Hardware.config['cores']))

        frequency = config.freq

        print("Applying configuration: {} @{}MHz".format(",".join([str(w) for w in workers]), frequency/1000))

        for w in self.workers:
            w.frequency(frequency)
            if w.localid in workers:
                w.enable()
            else:
                w.disable()

        self._active_configuration = config

    # Our main loop
    def run(self):
        try:
            while True:
                # Output the latest counter values
                self._ectrl._pull_monitoring_data()
                ctr_values = []
                for name, ctr in self.counters.items():
                    if len(ctr.values(False)) > 0:
                        ctr_values.append((name, ctr.values(False)[-1].value))

                print(" ".join(["{}: {}".format(n, v) for n, v in ctr_values]))

                with self._lock:
                    if self._changed:
                        # The system configuration changed â€¦ update our configurations accordingly
                        self._update_configurations()

                        best = self._find_best_configuration(None)
                        self._apply_configuration(best)
                        self._changed = False
                    else:
                        # Check if we are able to achieve the target transactions/second
                        started = self.counters["started"].values(False)[-1].value
                        finished = self.counters["finished"].values(False)[-1].value

                        if abs(started - finished) > (started) * 0.05:
                            best = self._find_best_configuration(started)
                            self._apply_configuration(best)

                # Wait for another update of the data
                time.sleep(1)

        except KeyboardInterrupt:
            # Someone interrupted us - we are done now :)
            pass


# Main
def main():
    # Parse the command line arguments
    arguments = ArgumentParser(description="EUF manager for ERIS")
    arguments.add_argument("--url", help="The url where the ERIS server can be reached (default=localhost)",
            type=str, dest="url", default="localhost")
    arguments.add_argument("--port", help="The port at which the ERIS server can be reached (default=5189)",
            type=int, dest="port", default=5189)
    arguments.add_argument("--user", help="The user that should be used to connect to ERIS (default=euf)",
            type=str, dest="user", default="euf")
    arguments.add_argument("--passwd", help="The password that should be used to connect to ERIS (default=euf)",
            type=str, dest="passwd", default="euf")

    parsed_args = arguments.parse_args()

    # Connect to ERIS
    ectrl = ErisCtrl(parsed_args.url, parsed_args.port, parsed_args.user, parsed_args.passwd)
    try:
        ectrl._login()
    except ErisCtrlError:
        print("Failed to connect to ERIS!")
        sys.exit(1)

    # Prepare ERIS
    ectrl.energy_management(False, False)       # Turn of ERIS' energy control loop (we are doing this now!)
    for w in ectrl.workers():                   # Turn on all ERIS workers
        w.enable()

    # Start the EUF and flask threads
    euf_thread = EUFThread(ectrl)
    flask_thread = FlaskThread(app, euf_thread)

    euf_thread.start()
    flask_thread.start()

    # Wait for the EUF thread to join
    euf_thread.join()

    # Shutdown everything
    flask_thread.shutdown()
    flask_thread.join()

if __name__ == "__main__":
    main()
